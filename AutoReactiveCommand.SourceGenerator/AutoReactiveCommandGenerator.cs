using System.CodeDom.Compiler;
using System.Text;
using AutoReactiveCommandSourceGenerator.Attributes;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace AutoReactiveCommandSourceGenerator
{

  [Generator]
  public class AutoReactiveCommandGenerator : IIncrementalGenerator
  {
    public void Initialize (IncrementalGeneratorInitializationContext context) {
      var distinctClasses = new HashSet<string>();
      var generatorInfo = context.SyntaxProvider
          .ForAttributeWithMetadataName("AutoReactiveCommandSourceGenerator.Attributes.AutoReactiveCommandAttribute",
                                        (node, ct) => Utils.CouldBeMethodWithAttributeInPartialClass(node, ct, distinctClasses),
                                        GetTypeToGenerate)
            .WithTrackingName("InitialExtraction")
            .Where(m => m is not null)
            .WithTrackingName("RemovingNulls");

      context.RegisterSourceOutput(generatorInfo, (spc, classSyntax) => Execute(in spc, classSyntax));
    }

    static ClassExtensionInfo? GetTypeToGenerate (GeneratorAttributeSyntaxContext context, CancellationToken ct) {
      if (context.TargetSymbol is not IMethodSymbol targetSymbol) {
        return null;
      }
      var declaredClass = context.TargetNode.Parent as ClassDeclarationSyntax;
      var semanticModel = context.SemanticModel;
      ct.ThrowIfCancellationRequested();

      if (!declaredClass.Modifiers.Any(SyntaxKind.PartialKeyword))
        return null;

      var classSymbol = (INamedTypeSymbol)ModelExtensions.GetDeclaredSymbol(semanticModel, declaredClass)!;
      var classExtensionInfo = new ClassExtensionInfo {
        ClassName = declaredClass.Identifier.ValueText,
        ClassNamespace = classSymbol.ContainingNamespace.ToString(),
        DeclarationSyntax = declaredClass
      };

      var methodMembers = declaredClass.Members.OfType<MethodDeclarationSyntax>().ToList();
      foreach (var methodSyntax in methodMembers) {
        var methodSymbol = (IMethodSymbol)ModelExtensions.GetDeclaredSymbol(semanticModel, methodSyntax)!;
        var methodAttributes = methodSyntax.AttributeLists
                             .SelectMany(a => a.Attributes)
                             .Where(a => a.Name.ToString() == nameof(AutoReactiveCommandAttribute) || a.Name.ToString() == "AutoReactiveCommand")
                             .ToList();
        if (methodAttributes.Any()) {

          bool isTask = Utils.IsTaskReturnType(methodSymbol.ReturnType);
          var realReturnType = isTask ? Utils.GetReturnType(methodSymbol.ReturnType) : methodSymbol.ReturnType;
          var methodParameters = methodSymbol.Parameters.ToList();
          if (methodParameters.Count > 1)
            continue; // Too many parameters, abort

          classExtensionInfo.CommandExtensionInfos.Add(new() {
            MethodName = methodSymbol.Name,
            MethodReturnType = realReturnType,
            IsTask = isTask,
            IsReturnTypeVoid = Utils.IsVoid(realReturnType) || Utils.IsTaskReturnType(realReturnType),
            ArgumentType = methodParameters.SingleOrDefault()?.Type
          });
        }
      }

      return classExtensionInfo;
    }


    public string TrimEnd (string inputText, string value, StringComparison comparisonType = StringComparison.CurrentCultureIgnoreCase) {
      if (!string.IsNullOrEmpty(value)) {
        while (!string.IsNullOrEmpty(inputText) && inputText.EndsWith(value, comparisonType)) {
          inputText = inputText.Substring(0, (inputText.Length - value.Length));
        }
      }

      return inputText;
    }


    private string Execute (in SourceProductionContext ctx, ClassExtensionInfo classExtensionInfo) {
      bool isAbstract = classExtensionInfo.DeclarationSyntax.Modifiers.Any(SyntaxKind.AbstractKeyword);
      StringWriter stringStream = new StringWriter();
      var writer = new IndentedTextWriter(stringStream, "  ");
      writer.WriteLine("// <auto-generated>");
      writer.WriteLine($"namespace {classExtensionInfo.ClassNamespace};");
      writer.WriteLine($"public {(isAbstract ? "abstract" : null)} partial class {classExtensionInfo.ClassName} {classExtensionInfo.DeclarationSyntax.TypeParameterList} {classExtensionInfo.DeclarationSyntax.ConstraintClauses} {{");
      writer.Indent++;
      foreach (var commandExtensionInfo in classExtensionInfo.CommandExtensionInfos) {
        var outputType = commandExtensionInfo.GetOutputTypeText();
        var inputType = commandExtensionInfo.GetInputTypeText();
        string commandName = TrimEnd(commandExtensionInfo.MethodName, "Impl");
        writer.WriteLine($"public ReactiveUI.ReactiveCommand<{inputType}, {outputType}> " + $"{commandName} {{ get; private set; }}");
      }
      writer.WriteLine("");
      writer.WriteLine("public void InitializeCommands() {");
      writer.Indent++;
      foreach (var commandExtensionInfo in classExtensionInfo.CommandExtensionInfos) {
        string commandName = TrimEnd(commandExtensionInfo.MethodName, "Impl");
        var outputType = commandExtensionInfo.GetOutputTypeText();
        var inputType = commandExtensionInfo.GetInputTypeText();
        var types = (commandExtensionInfo.ArgumentType != null && !commandExtensionInfo.IsReturnTypeVoid) ? $"<{inputType},{outputType}>" :
                    (commandExtensionInfo.ArgumentType != null && commandExtensionInfo.IsReturnTypeVoid) ? $"<{inputType}>" : "";
        writer.WriteLine(!commandExtensionInfo.IsTask
            ? $"{commandName} = ReactiveUI.ReactiveCommand.Create{types}({commandExtensionInfo.MethodName});"
            : $"{commandName} = ReactiveUI.ReactiveCommand.CreateFromTask{types}({commandExtensionInfo.MethodName});");
      }
      writer.Indent--;
      writer.WriteLine("}");
      writer.Indent--;
      writer.WriteLine("}");
      string source = stringStream.ToString();
      ctx.AddSource(classExtensionInfo.ClassName + ".g.cs", SourceText.From(source, Encoding.UTF8));
      return source;

    }

  }
}